/*
 *   
 *   Problem 14
 *   
 *      Published on Friday, 5th April 2002, 06:00 pm; Solved by 123356
 *   
 *      The following iterative sequence is defined for the set of positive
 *      integers:
 *   
 *      n -> n/2 (n is even)
 *      n -> 3n + 1 (n is odd)
 *   
 *      Using the rule above and starting with 13, we generate the following
 *      sequence:
 *      13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
 *   
 *      It can be seen that this sequence (starting at 13 and finishing at 1)
 *      contains 10 terms. Although it has not been proved yet (Collatz
 *      Problem), it is thought that all starting numbers finish at 1.
 *   
 *      Which starting number, under one million, produces the longest chain?
 *   
 *      NOTE: Once the chain starts the terms are allowed to go above one
 *      million.
 *
*/

#include <stdio.h>
#include <stdlib.h>

#define CEILING 1000000

int CollatzChainLength(unsigned long num, int *chainLengths);

int main()
{
	/* Array that holds previously calculated chain lengths */
	int *chainLengths = malloc(sizeof(int) * CEILING);

	int longestStart = 0;
	unsigned long i;
	for (i = 1; i < CEILING; i = i + 2) {
		chainLengths[i] = CollatzChainLength(i, chainLengths);
		if (chainLengths[i] > chainLengths[longestStart])
			longestStart = i;
	}

	printf("The longest Collatz chain (starting under one million) contains %d terms and is generated by starting at %d.\n",
		 chainLengths[longestStart], longestStart);
	free(chainLengths);
	return 0;
}

int CollatzChainLength(unsigned long num, int *chainLengths)
{
	int length = 1;
	while (num != 1) {
		if (num % 2 == 0) {
			/* If the next chain element is already calculated, just add its length. */
			if ((num / 2) < CEILING && chainLengths[num / 2] != 0) {
				length = length + chainLengths[num / 2];
				break;
			} else {
				num = num / 2;
			}
		} else {
			num = 3 * num + 1;
		}
		length++;
	}
	return length;
}
